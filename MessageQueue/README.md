# 对于共享内存消息队列的若干尝试

## 规定

服务端产生消息，消息为timespec结构体，消息内容可以认为是压入队列时间

	struct timespec
	{
		long tv_sec;
		long tv_nsec;
	};

消息产生频率对于测量结构影响非常大，所以现在规定消息间隔为 usleep(rand()%20)

客户端读取消息，计算当前时间和消息内容的时间的差，由于倘若客户端读取速度比服务端产生消息慢，则会导致消息在队列中积压，时间测试不准确，所以测试效率都保证客户端实时读取消息、但是正确性测试时会考虑消息积压问题，commit代码中客户端都没有sleep延时

原则上我都是先开client，再开server，所以反过来可能会崩溃啥的……

## 注释位置

我详细注释了broadcast文件夹下的代码

## Boost-spsc

平均延时1097ns

## simple-queue

仿照boost-spsc-queue自己编写了一个队列。但是由于没怎么搞懂memory\_order，所以这方面就没有怎么处理，不过毕竟spsc也没找到竞争的情况……所以实际上全部使用memory\_order\_relax 都是可以的

平均延时948ns

## broadcaster(-single)

假设存在以下猜测：

* 消息发出速度远小于消息处理速度（例如server比client多一个usleep(20)）
* 进程a分别储存变量x,y的值（x,y在内存中相邻），则进程b读取到y值时，x值也是最新的（网上所说的内存顺序问题经测试并不经常出现，应该是根本没有出现过）

server维护一个循环队列，一直往后面写数，啥也不管，在写数时顺便保存一个时间戳

client在循环队列中，沿着递增时间戳寻找，并且依次弹数

该方法可以解决多个client的情况，如果证明这种办法靠谱的话，可以进而改进为mpmc结构

平均延时 362ns，两个client：606ns
